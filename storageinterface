--[[
 _    _              _      _             
| |  | |            | |    | |            
| |  | |  ___   ___ | |__  | |  ___  _ __ 
| |/\| | / _ \ / _ \| '_ \ | | / _ \| '__|
\  /\  /|  __/|  __/| |_) || ||  __/| |   
 \/  \/  \___| \___||_.__/ |_| \___||_|   

Copyright (c)2013  Horace Weebler

This program is part of a collection of works currently lacking a
decent title.  However, the idea is storage.  Storage that is
highly customizable, easily deployed, and modular.

This program is free software: you can redistribute it and/or modify
it any way you like.  However, please let me know if you do modify it
as I would appreciate ideas and feedback.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. In short,
don't blame me if your server blows up.

--]]
print("Starting up interface..")
--rednet.open("back")
local database = {}
local idLookup = {}
local curmons = nil
local currentResult = nil
local lastSorterResponse = 0
local storageClusters = {}

function newT( t )
   local mt = {}
   -- set methods
   mt.__index = {
      -- set key order table inside __index for faster lookup
      _korder = {},
      -- traversal of hidden values
      hidden = function() return pairs( mt.__index ) end,
      -- traversal of table ordered: returning index, key
      ipairs = function( self ) return ipairs( self._korder ) end,
      -- traversal of table
      pairs = function( self ) return pairs( self ) end,
      -- traversal of table ordered: returning key,value
      opairs = function( self )
         local i = 0
         local function iter( self )
            i = i + 1
            local k = self._korder[i]
            if k then
               return k,self[k]
            end
         end
         return iter,self
      end,
      -- to be able to delete entries we must write a delete function
      del = function( self,key )
         if self[key] then
            self[key] = nil
            for i,k in ipairs( self._korder ) do
               if k == key then
                  table.remove( self._korder, i )
                  return
               end
            end
         end
      end,
   }
   -- set new index handling
   mt.__newindex = function( self,k,v )
      if k ~= "del" and v then
         rawset( self,k,v )
         table.insert( self._korder, k )
      end      
   end
   return setmetatable( t or {},mt )
end

--------------------------------------
-- Insert value of any type into array
--------------------------------------
local function arrayInsert( ary, val, idx )
    -- Needed because table.insert has issues
    -- An "array" is a table indexed by sequential
    -- positive integers (no empty slots)
    local lastUsed = #ary + 1
    local nextAvail = lastUsed + 1

    -- Determine correct index value
    local index = tonumber(idx) -- Don't use idx after this line!
    if (index == nil) or (index > nextAvail) then
        index = nextAvail
    elseif (index < 1) then
        index = 1
    end

    -- Insert the value
    if ary[index] == nil then
        ary[index] = val
    else
        -- TBD: Should we try to allow for skipped indices?
        for j = nextAvail,index,-1 do
            ary[j] = ary[j-1]
        end
        ary[index] = val
    end
end

--------------------------------
-- Compare two items of any type
--------------------------------
local function compareAnyTypes( op1, op2 ) -- Return the comparison result
    -- Inspired by http://lua-users.org/wiki/SortedIteration
    local type1, type2 = type(op1),     type(op2)
    local num1,  num2  = tonumber(op1), tonumber(op2)
    
    if ( num1 ~= nil) and (num2 ~= nil) then  -- Number or numeric string
        return  num1 < num2                     -- Numeric compare
    elseif type1 ~= type2 then                -- Different types
        return type1 < type2                    -- String compare of type name
    -- From here on, types are known to match (need only single compare)
    elseif type1 == "string"  then            -- Non-numeric string
        return op1 < op2                        -- Default compare
    elseif type1 == "boolean" then
        return op1                              -- No compare needed!
         -- Handled above: number, string, boolean
    else -- What's left:   function, table, thread, userdata
        return tostring(op1) < tostring(op2)  -- String representation
    end
end

-------------------------------------------
-- Iterate over a table in sorted key order
-------------------------------------------
local function pairsByKeys (tbl, func)
    -- Inspired by http://www.lua.org/pil/19.3.html
    -- and http://lua-users.org/wiki/SortedIteration

    if func == nil then
        func = compareAnyTypes
    end

    -- Build a sorted array of the keys from the passed table
    -- Use an insertion sort, since table.sort fails on non-numeric keys
    local ary = {}
    local lastUsed = 0
    for key --[[, val--]] in pairs(tbl) do
        if (lastUsed == 0) then
            ary[1] = key
        else
            local done = false
            for j=1,lastUsed do  -- Do an insertion sort
                if (func(key, ary[j]) == true) then
                    arrayInsert( ary, key, j )
                    done = true
                    break
                end
            end
            if (done == false) then
                ary[lastUsed + 1] = key
            end
        end
        lastUsed = lastUsed + 1
    end

    -- Define (and return) the iterator function
    local i = 0                -- iterator variable
    local iter = function ()   -- iterator function
        i = i + 1
        if ary[i] == nil then
            return nil
        else
            return ary[i], tbl[ary[i]]
        end
    end
    return iter
end
SortFunc = function (myTable)
    local t = {}
    for title,value in pairsByKeys(myTable) do
        table.insert(t, { title = title, value = value })
    end
    myTable = t
    return myTable
end
---------------------------------------------
-- Return indentation string for passed level
---------------------------------------------
local function tabs(i)
    return string.rep(".",i).." "   -- Dots followed by a space
end

-----------------------------------------------------------
-- Return string representation of parameter's value & type
-----------------------------------------------------------
local function toStrType(t)
    local function fttu2hex(t) -- Grab hex value from tostring() output
        local str = tostring(t);
        if str == nil then
            return "tostring() failure! \n"
        else
            local str2 = string.match(str,"[ :][ (](%x+)")
            if str2 == nil then
                return "string.match() failure: "..str.."\n"
            else
                return "0x"..str2
            end
        end
    end
    -- Stringify a value of a given type using a table of functions keyed
    -- by the name of the type (Lua's version of C's switch() statement).
    local stringify = {
        -- Keys are all possible strings that type() may return,
        -- per http://www.lua.org/manual/5.1/manual.html#pdf-type.
        ["nil"]			= function(v) return "nil (nil)"			    end,
        ["string"]		= function(v) return '"'..v..'" (string)'	    end,
        ["number"]		= function(v) return v.." (number)"			    end,
        ["boolean"]		= function(v) return tostring(v).." (boolean)"  end,
        ["function"]	= function(v) return fttu2hex(v).." (function)" end,
        ["table"]		= function(v) return fttu2hex(v).." (table)"	end,
        ["thread"]		= function(v) return fttu2hex(v).." (thread)"	end,
        ["userdata"]	= function(v) return fttu2hex(v).." (userdata)" end
    }
    return stringify[type(t)](t)
end

-------------------------------------
-- Count elements in the passed table
-------------------------------------
local function lenTable(t)		-- What Lua builtin does this simple thing?
    local n=0                   -- '#' doesn't work with mixed key types
    if ("table" == type(t)) then
        for key in pairs(t) do  -- Just count 'em
            n = n + 1
        end
        return n
    else
        return nil
    end
end

--------------------------------
-- Pretty-print the passed table
--------------------------------
local function do_dumptable(t, indent, seen)
    -- "seen" is an initially empty table used to track all tables
    -- that have been dumped so far.  No table is dumped twice.
    -- This also keeps the code from following self-referential loops,
    -- the need for which was found when first dumping "_G".
    if ("table" == type(t)) then	-- Dump passed table
        seen[t] = 1
        if (indent == 0) then
            print ("The passed table has "..lenTable(t).." entries:")
            indent = 1
        end
        for f,v in pairsByKeys(t) do
            if ("table" == type(v)) and (seen[v] == nil) then    -- Recurse
                print( tabs(indent)..toStrType(f).." has "..lenTable(v).." entries: {")
                do_dumptable(v, indent+1, seen)
                print( tabs(indent).."}" )
            else
                print( tabs(indent)..toStrType(f).." = "..toStrType(v))
            end
        end
    else
        print (tabs(indent).."Not a table!")
    end
end

--------------------------------
-- Wrapper to handle persistence
--------------------------------
function dumptable(t)   -- Only global declaration in the package
    -- This wrapper exists only to set the environment for the first run:
    -- The second param is the indentation level.
    -- The third param is the list of tables dumped during this call.
    -- Getting this list allocated and freed was a pain, and this
    -- wrapper was the best solution I came up with...
    return do_dumptable(t, 0, {})
end

 function makemsg(idfrom, idto, msgType, msg)
	local final = ""
	final = "HORACEV1|"  .. idfrom .. "|" .. idto .. "|" .. msgType .."|" .. msg
	return final
end


function explode(div,str)
    if (div=='') then return false end
    local pos,arr = 0,{}
    for st,sp in function() return string.find(str,div,pos,true) end do
        table.insert(arr,string.sub(str,pos,st-1))
        pos = sp + 1
    end
    table.insert(arr,string.sub(str,pos))
    return arr
end


function validateWeeblerMsg( msg )
	 --print("Validating message... ")
	 local m = 0
	 local ret = false
	 local cmd = nill
	 local cmdType = nill
	 local directedTo = 0
	 for i,v in pairs(explode("|", message)) do
		 if ( m == 0 ) then
			 if( v == "HORACEV1" ) then
				-- print("WeeblerV1 message: TRUE")
				 else
					 return ret
			 end
		 end
		 if ( m == 1 ) then
			 --print( "Msg From: " .. v )
		 end
		 if ( m == 2 ) then
			if( tonumber(v) == os.getComputerID() ) then
				--print("Received a message to us! " .. msg)
				directedTo = tonumber(v)

			end
			 if ( v ~= "0" and tonumber(v) ~= os.getComputerID() ) then
				 --print( "Msg To: " .. v .. " which is not us, validation falied.")
				 --directedTo = tonumber(v)
				 return false
				 else
					 ret = true
					
			 end
		 end
		 if ( m == 3 ) then
			 --print( "CmdType: " .. v )
			 ctype = v
			 --cmd = v
			 --return ret, cmd
		 end
		 if ( m == 4 ) then
			 --print( "Command: " .. v )
			 cmd = v
			 return ret, ctype, cmd, directedTo
		 end
		 --print("[" .. i .. "] = " .. v)
		 m = m+1
	 end
	 return ret
 end
 
 function loadTable(str)
	--local file = fs.open(name,"r")
	--local data = file.readAll()
	--file.close()
	return textutils.unserialize(str)
end

function sendCmd( toid, cmd )
	if (toid == 0) then
		rednet.broadcast(cmd)
		else
			rednet.send( toid, cmd )
	end
	
end



function processGetResponse(cmd)
	local tmp = loadTable( cmd )
	--print(to_string(tmp))
	currentResult = {}
	currentResult.result = tmp.result
	currentResult.msg = tmp.msg
end
function processQueryClusterListResponse(cmd)
	local tmp = loadTable( cmd )
	--print(to_string(tmp))-
	--print(cmd)
	--print(cmd)
	if( tmp ~= nil and type(tmp) == "table" and lenTable(tmp) > 0 ) then
		storageClusters = tmp
		--print(to_string(tmp))
		--for key, value in pairs (tmp) do
			--print(to_string(value))
			--print(value.computerLabel)
		--end
		-- for item = 1, #tmp do
			-- for key, value in pairs (tmp[item]) do
			-- end
		-- end
	end
end
function processCmd(ctype, cmd, resp, to)
	--print(ctype)
	if( ctype:lower() == "querystorageresponse" ) then
		lastSorterResponse = os.clock()
		local tmp = loadTable( cmd )
		if( tmp ~= nil and #tmp > 0 and type(tmp) == "table" ) then
			for item = 1, #tmp do
				for key, value in pairs (tmp[item]) do
					--print( item .. " " .. key .. " " .. queryItemName(tonumber(value.uuid)) )
					local bfound = false
					for keyb, valueb in pairs (database) do
						if( keyb == tonumber(value.uuid) ) then
							bfound = true
							valueb.amount = value.amount
						end
					end
					if (bfound ~= true) then
						local newitem = {}
						newitem.uuid = value.uuid
						newitem.amount = value.amount
						table.insert(database, tonumber(value.uuid), newitem) 
					end
					--updateScreen()
				end
			end
		end
	end
	if( ctype:lower() == "restart" ) then
		print("Restart received")
		sleep(5)
		processRestartCmd(resp);
	end
	if( ctype:lower() == "queryclusterlistresponse" ) then
		--print("queryClusterListResponse received")
		--sleep(5)
		--processRestartCmd(resp);
		processQueryClusterListResponse(cmd)
	end
	if( ctype:lower() == "getresponse" ) then
		if( to == os.getComputerID() ) then
		--	print("Response was directed to " .. to)
		processGetResponse(cmd)
		end
		--print("Get Response!")
		--sleep(5)
		--processRestartCmd(resp);
	end
end

function table_print (tt, indent, done)
  done = done or {}
  indent = indent or 0
  if type(tt) == "table" then
    local sb = {}
    for key, value in pairs (tt) do
      table.insert(sb, string.rep (" ", indent)) -- indent it
      if type (value) == "table" and not done [value] then
        done [value] = true
        table.insert(sb, "{\n");
        table.insert(sb, table_print (value, indent + 2, done))
        table.insert(sb, string.rep (" ", indent)) -- indent it
        table.insert(sb, "}\n");
      elseif "number" == type(key) then
        table.insert(sb, string.format("\"%s\"\n", tostring(value)))
      else
        table.insert(sb, string.format(
            "%s = \"%s\"\n", tostring (key), tostring(value)))
       end
    end
    return table.concat(sb)
  else
    return tt .. "\n"
  end
end

function to_string( tbl )
    if  "nil"       == type( tbl ) then
        return tostring(nil)
    elseif  "table" == type( tbl ) then
        return table_print(tbl)
    elseif  "string" == type( tbl ) then
        return tbl
    else
        return tostring(tbl)
    end
end

-- see if the file exists
function file_exists(file)
 -- local f = io.open(file, "rb")
-- if f then f:close() end
--  return f ~= nil
end

function queryItemName(uuid)
	if (idLookup == nil or #idLookup == 0 ) then
		return "Loading.."
	end
	local bFound = false
	local n = nil
	for key, value in pairs (idLookup) do
		if ( tonumber(value.uuid) == tonumber(uuid) ) then
			bFound = true
			n = value.name
			break
		end
	end
	if ( not bFound ) then
		return "Unknown Item ID (" .. uuid .. ")"
	end
	return n
end

function loadLookups(name)
	local file = fs.open(name,"r")
	--local data = file.readAll()
	local tb = {}
	local eof = false;
	while( not eof ) do
		local l = file.readLine()

		if ( l ~= nil ) then
			local ltb = explode("|", l)
			local tm = 1
			local tkey = nil
			for key, value in pairs (ltb) do
				if ( tm % 2 ~= 0 ) then
					tkey = value
					else
						local blah = { }
						blah.uuid = tkey
						blah.name = value
						table.insert(tb, blah)
				end
				tm = tm + 1
			end
			else
				eof = true
		end
	end

	file.close()
	idLookup = tb

end
function locateScreens()
		local dirs = { "top", "bottom", "back", "front", "left", "right" }
		--local dirs = {0, 1, 2, 3, 4, 5}
		local found = {}
		local cnt = 0
		for i, dir in ipairs(dirs) do
		  --print (name)
		  	if peripheral.isPresent(dir) and peripheral.getType(dir) == "monitor" then
				local newscreen = {}
				
				local obj = peripheral.wrap(dir)
				newscreen.obj = obj
				local x, y = newscreen.obj.getSize()
				newscreen.side = dir
				newscreen.width = x
				newscreen.height = y
				table.insert(found, cnt, newscreen)
				cnt = cnt + 1
			end
		end
		return found
end
function initModem()
		local dirs = { "top", "bottom", "back", "front", "left", "right" }
		for i, dir in ipairs(dirs) do
		  	if peripheral.isPresent(dir) and peripheral.getType(dir) == "modem" then
				rednet.open(dir)
				--print("Found a modem on the " .. dir .. " side.")
				return true
			end
		end
		print("A modem must be attached for the storage interface application to function correctly.")
		return false
end
printItemID = function(id)
	print("Item clicked = " .. id )
end

modifySelectedCount = function(args)
	--print("Modifying on screen amounts" .. args.modifier)
	args.oldargs.count = args.oldargs.count + args.modifier
	resourceSelectedScreen(args.oldargs)
end


function printToCenterScreen(mon, msg, scale)
	mon.clear()
	mon.setTextScale(scale)
	mon.write("")
	local x, y = mon.getSize()
	local midpointx = x / 2
	local midpointy = y / 2
	local strl = #msg
	strl = ((x - (strl))/2)
	local colpos = strl
	local linepos = midpointy
	
	mon.setCursorPos(colpos,linepos)
	
	mon.write(msg)

end
sendRebootPendingScreen = function(args)

	local req = {}
	currentResult = nil
	--req.uuid = args.uuid
	--req.amount = args.count
	
	local s = makemsg(os.getComputerID(), tostring(args.computerID), "restart", "")
	sendCmd(0, s)
	clusterSelectedScreen(args)
end
sendDumpPendingScreen = function(args)

	local req = {}
	currentResult = nil
	--req.uuid = args.uuid
	--req.amount = args.count
	
	local s = makemsg(os.getComputerID(), tostring(args.computerID), "dump", "")
	sendCmd(0, s)
	clusterSelectedScreen(args)
end
getRequestPendingScreen = function(args)
	if( args.count <= 0 ) then
	resourceSelectedScreen(args)
	return
	end
	args.mon.pageName = "getRequestPendingScreen" 

	args.mon.obj.clear()

	local req = {}
	currentResult = nil
	req.uuid = args.uuid
	req.amount = args.count
	local found = false
	local idofcluster = 0
	local nameofcluster = ""
	for key, value in pairs (storageClusters) do
		for x, y in pairs(value.resources) do
			--print(y)
			--print(.uuid)
			for a, b in pairs(y) do
				if( b.uuid == args.uuid ) then
					idofcluster = value.computerID
					nameofcluster = value.computerLabel
					--print(value.computerID)
					--print(value.computerLabel)
					if( value.online == true ) then
						found = true
						else
						found = false
					end
				end
			end
			

		end
	end
	if( found == false ) then
		if( nameofcluster ~= "" ) then
			printToCenterScreen(args.mon.obj, "Cluster " .. nameofcluster .. " [" .. idofcluster .. "]" .. " is offline", 1)
			sleep(2)
			else
				printToCenterScreen(args.mon.obj, "Unable to find resource", 1)
				sleep(2)
		end

		printItemPageEx(args.cancelargs)
		return
	end
	local s = makemsg(os.getComputerID(), 0, "get", textutils.serialize(req))
	sendCmd(0, s)
	local x = os.clock()
	
	while (true) do
		if( currentResult ~= nil ) then
			printToCenterScreen(args.mon.obj, "INCOMING!", 2)
			sleep(2)
			printItemPageEx(args.cancelargs)
			return
		end
		if (os.clock() - x) > 10 then
			printToCenterScreen(args.mon.obj, "FAIL", 2)
			sleep(2)
			printItemPageEx(args.cancelargs)
			--local file = 'idlookup'
			--local status, err = pcall(loadLookups, file)
			--x = os.clock()
			return
		end
		
		if( math.floor(os.clock()) % 2 > 0 ) then

			printToCenterScreen(args.mon.obj, "Requesting resources. ", 1)
			sleep(.5)
			printToCenterScreen(args.mon.obj, "Requesting resources..", 1)
			else
			printToCenterScreen(args.mon.obj, "Requesting resources  ", 1)
		end
		sleep(.5)
	end
	
	

	--print("Sending request!!!!" .. s)
	
	
	
	
	--printItemPageEx(args.cancelargs)
end

menuScreen = function(args)

end

clusterSelectedScreen = function(args)
	--print("Cluster selected!")
		local colpos = 3 -- start positions for the page
	local linepos = 2
	args.mon.hitgrid = {}
	args.mon.obj.setTextScale(2) --Sets size
	local x, y = args.mon.obj.getSize()
	--print("Inside clusterSelectedScreen")
	args.mon.pageName = "clusterSelectedScreen" 
	linepos = y -- set to the bottom of the screen
	args.mon.obj.clear()
	args.mon.obj.setCursorPos(colpos,linepos)
	args.mon.obj.write("Cancel")
	
	local newhit = {} -- our new hit test obj
	local topLeft = {}
	local bottomRight = {}
	topLeft.x = colpos
	topLeft.y = linepos
	bottomRight.x = #"Cancel"--colpos+50 -- fixed number for now
	bottomRight.y = linepos
	newhit.topLeft = topLeft
	newhit.bottomRight = bottomRight
	newhit.func = printClustersScreenEx
	newhit.funcargs = args.cancelargs
	table.insert(args.mon.hitgrid, newhit)
	
	
		
	linepos = 2
	local midpoint = x / 2
	local strl = #("Cluster: " .. args.computerLabel)
	local strl = ((x - (strl))/2)
	colpos = strl
	args.mon.obj.setCursorPos(colpos,linepos)
	args.mon.obj.write("Cluster: " .. args.computerLabel)
	
	
	linepos = y / 2
	local midpoint = x / 2
	
	local strl = #"Reboot"
	local strl = ((x - (strl))/2)
	colpos = strl
	args.mon.obj.setCursorPos(colpos,linepos)
	newhit = {} -- our new hit test obj
	topLeft = {}
	bottomRight = {}
	topLeft.x = colpos
	topLeft.y = linepos
	bottomRight.x = colpos + #"Reboot"
	bottomRight.y = linepos
	newhit.topLeft = topLeft
	newhit.bottomRight = bottomRight
	newhit.func = sendRebootPendingScreen
	newhit.funcargs = args
	table.insert(args.mon.hitgrid, newhit)
	args.mon.obj.write("Reboot")
	
	linepos = linepos + 2
	local midpoint = x / 2
	local strl = #"Dump All"
	local strl = ((x - (strl))/2)
	colpos = strl
	args.mon.obj.setCursorPos(colpos,linepos)
	newhit = {} -- our new hit test obj
	topLeft = {}
	bottomRight = {}
	topLeft.x = colpos
	topLeft.y = linepos
	bottomRight.x = colpos + #"Dump All"
	bottomRight.y = linepos
	newhit.topLeft = topLeft
	newhit.bottomRight = bottomRight
	newhit.func = sendDumpPendingScreen
	newhit.funcargs = args
	table.insert(args.mon.hitgrid, newhit)
	args.mon.obj.write("Dump All")

end


resourceSelectedScreen = function(args)

	-- args.mon is the current monitor
	-- args.uuid is the UID of the crap we're expecting
	-- args.name is the name of the UUID for human readability
	-- args.cancel is the function to which we default cancel to
	-- args.amount is how much we got
	-- args.count is the selected amount
	--local cnt = args.count
	local colpos = 3 -- start positions for the page
	local linepos = 2
	args.mon.hitgrid = {}
	args.mon.obj.setTextScale(2) --Sets size
	local x, y = args.mon.obj.getSize()
	--print("Inside resourceSelectedScreen")
	args.mon.pageName = "resourceSelectedScreen" 
	linepos = y -- set to the bottom of the screen
	args.mon.obj.clear()
	args.mon.obj.setCursorPos(colpos,linepos)
	args.mon.obj.write("Cancel")
	
	local newhit = {} -- our new hit test obj
	local topLeft = {}
	local bottomRight = {}
	topLeft.x = colpos
	topLeft.y = linepos
	bottomRight.x = #"Cancel"--colpos+50 -- fixed number for now
	bottomRight.y = linepos
	newhit.topLeft = topLeft
	newhit.bottomRight = bottomRight
	newhit.func = printItemPageEx
	newhit.funcargs = args.cancelargs
	table.insert(args.mon.hitgrid, newhit)
	
	linepos = linepos - 2
	args.mon.obj.setCursorPos(colpos,linepos)
	newhit = {} -- our new hit test obj
	topLeft = {}
	bottomRight = {}
	topLeft.x = colpos
	topLeft.y = linepos
	bottomRight.x = colpos + #"-8"--colpos+50 -- fixed number for now
	bottomRight.y = linepos
	newhit.topLeft = topLeft
	newhit.bottomRight = bottomRight
	newhit.func = modifySelectedCount
	local tmpargs = {}
	tmpargs.oldargs = args
	newhit.funcargs = tmpargs
	if( args.count >= 8 ) then 
		tmpargs.modifier = -8 
		else
		if( args.count ~= 0 ) then
			tmpargs.modifier = (args.count - args.amount) - args.count
			else
			tmpargs.modifier = 0
		end
	end
	table.insert(args.mon.hitgrid, newhit)
	args.mon.obj.write("-8")
	
	local midpoint = x / 2
	local strl = #"Send"
	local strl = midpoint - (strl/2)
	colpos = strl
	args.mon.obj.setCursorPos(colpos,linepos)
	newhit = {} -- our new hit test obj
	topLeft = {}
	bottomRight = {}
	topLeft.x = colpos
	topLeft.y = linepos
	bottomRight.x = colpos + #"Send"
	bottomRight.y = linepos
	newhit.topLeft = topLeft
	newhit.bottomRight = bottomRight
	newhit.func = getRequestPendingScreen
	newhit.funcargs = args
	table.insert(args.mon.hitgrid, newhit)
	args.mon.obj.write("Send")
	
	strl = #"+8"
	strl = x - 3 - strl
	colpos = strl
	args.mon.obj.setCursorPos(colpos,linepos)
	newhit = {} -- our new hit test obj
	topLeft = {}
	bottomRight = {}
	topLeft.x = colpos
	topLeft.y = linepos
	bottomRight.x = colpos + #"+8"--colpos+50 -- fixed number for now
	bottomRight.y = linepos
	newhit.topLeft = topLeft
	newhit.bottomRight = bottomRight
	newhit.func = modifySelectedCount
	local tmpargs = {}
	tmpargs.oldargs = args
		if( args.amount >= args.count + 8 ) then 
		tmpargs.modifier = 8
		else
		tmpargs.modifier = args.amount - args.count
	end
	newhit.funcargs = tmpargs


	--newhit.funcargs = args
	table.insert(args.mon.hitgrid, newhit)
	args.mon.obj.write("+8")
	
	linepos = linepos - 2 -- next section of the screen
	colpos = 3
	args.mon.obj.setCursorPos(colpos,linepos)
	newhit = {} -- our new hit test obj
	topLeft = {}
	bottomRight = {}
	topLeft.x = colpos
	topLeft.y = linepos
	bottomRight.x = colpos + #"-1"--colpos+50 -- fixed number for now
	bottomRight.y = linepos
	newhit.topLeft = topLeft
	newhit.bottomRight = bottomRight
	newhit.func = modifySelectedCount
	local tmpargs = {}
	tmpargs.oldargs = args
	newhit.funcargs = tmpargs
	if( args.count >= 1 ) then 
		tmpargs.modifier = -1 
		else
		if( args.count ~= 0 ) then
			tmpargs.modifier = (args.count - args.amount) - args.count
			else
			tmpargs.modifier = 0
		end
	end
	table.insert(args.mon.hitgrid, newhit)
	args.mon.obj.write("-1")
	
	--local midpoint = x / 2
	strl = #tostring(args.count)
	strl = midpoint - (strl/2)
	colpos = strl
	args.mon.obj.setCursorPos(colpos,linepos)
	args.mon.obj.write(tostring(args.count))
	
	strl = #"+1"
	strl = x - 3 - strl
	colpos = strl
	args.mon.obj.setCursorPos(colpos,linepos)
	newhit = {} -- our new hit test obj
	topLeft = {}
	bottomRight = {}
	topLeft.x = colpos
	topLeft.y = linepos
	bottomRight.x = colpos + #"+1"--colpos+50 -- fixed number for now
	bottomRight.y = linepos
	newhit.topLeft = topLeft
	newhit.bottomRight = bottomRight
	newhit.func = modifySelectedCount
	local tmpargs = {}
	tmpargs.oldargs = args
		if( args.amount >= args.count + 1 ) then 
		tmpargs.modifier = 1
		else
		tmpargs.modifier = args.amount - args.count
	end
	newhit.funcargs = tmpargs
	table.insert(args.mon.hitgrid, newhit)
	args.mon.obj.write("+1")

	linepos = linepos - 3 -- next section of the screen
	colpos = 3

	strl = #tostring(args.amount)
	strl = midpoint - (strl/2)
	colpos = strl
	args.mon.obj.setCursorPos(colpos,linepos)
	args.mon.obj.write(tostring(args.amount))
	
	
	linepos = linepos - 1--linepos - 2 -- next section of the screen
	colpos = 3

	strl = #tostring(args.name)
	strl = midpoint - (strl/2)
	colpos = strl
	args.mon.obj.setCursorPos(colpos,linepos)
	args.mon.obj.write(tostring(args.name))
end
printItemPageEx = function(args)
	args.m.obj.clear()
	--print("Printing page " ..  args.pageid)
	printItemPage(args.db, args.pageid, args.m)
end
printDisconnectedPage = function (mon)
	local colpos = 3 -- start positions for the page
	local linepos = 2
	--args.mon.hitgrid = {}
	--args.mon.obj.setTextScale(2) --Sets size
	--local x, y = args.mon.obj.getSize()
	--print("Inside printDisconnectedPage")
	printToCenterScreen(mon.obj, "Waiting for sorter..", 1 )
	sleep(1.5)
	printToCenterScreen(mon.obj, "Is it off?", 1 )
	sleep(1.5)
	printToCenterScreen(mon.obj, "Try turning it on..", 1 )

	return mon
end
printItemPage = function(db, pageid, m)
	--m.clear()
	m.obj.setCursorBlink(false)
	m.pageName = "printItemPage"
	m.pageid = pageid
	m.obj.setTextScale(1) --Sets size
	
	local hitgrid = {} -- our hit grid for the printed page
	
	local colpos = 3 -- start positions for the page
	local linepos = 2
	--
	local x, y = m.obj.getSize()
	
	local dbCount = 0;

	for key, value in pairs (db) do
		value.name = queryItemName(tonumber(value.uuid))
		dbCount = dbCount + 1
	end
	local ndatabase = SortFunc(db)
	
	table.sort(ndatabase, function(x,y) return x.value.name < y.value.name end)
	--local startid = (y-2) / (pageid-1)
	local maxcols = math.floor(x / 30)
	if ( maxcols == 0 ) then maxcols = 1 end

	
	local maxrows = (y-4) / 2
	local maxitemsdisplayed = math.floor(maxcols * maxrows)
	--local cnt = lenTable(ndatabase)
	local startid = maxitemsdisplayed * (pageid-1)--(pageid-1)  cnt;
	--print ("Database has " .. dbCount .. " items.")
	--print("start id " .. startid)
	local id = 0
	local tids = 0
	local bhasnext = false
	--print( "MAX X = " .. x .. " MAX Y = " .. y .. " MAXITEMS = " .. maxitemsdisplayed .. " startid= " .. startid)

	for _,t in ipairs(ndatabase) do 
			--print( "id " .. id .. " start id " .. startid .. " tids " .. tids .. " max items " .. maxitemsdisplayed )
			if (id >= startid and tids < maxitemsdisplayed ) then
				
				local newhit = {} -- our new hit test obj
				-- we're going to take the top left and bottom right
				local topLeft = {}
				local bottomRight = {}
				
				topLeft.x = colpos
				topLeft.y = linepos
				
				bottomRight.x = colpos+50 -- fixed number for now
				bottomRight.y = linepos
				
				newhit.topLeft = topLeft
				newhit.bottomRight = bottomRight
				newhit.func = resourceSelectedScreen
				-- args.mon is the current monitor
				-- args.uuid is the UID of the crap we're expecting
				-- args.name is the name of the UUID for human readability
				-- args.cancel is the function to which we default cancel to
				-- args.amount is how much we got
				-- args.count is how much they want, zero for default
				local args = {}
				args.mon = m
				args.uuid = t.value.uuid
				args.name = t.value.name
				args.cancel = printItemPage
				local cancelargs = {}
				cancelargs.db = db
				cancelargs.pageid = pageid
				cancelargs.m = m
				args.cancelargs = cancelargs
				args.amount = t.value.amount
				args.count = 0
				newhit.funcargs = args
				
				table.insert(hitgrid, newhit)
				
				m.obj.setCursorPos(colpos,linepos)
				m.obj.write(string.rep(" ",25)) -- clear the line
				m.obj.setCursorPos(colpos,linepos)
				m.obj.write(t.value.name)-- .. "\t" .. " Count = " .. t.value.amount );
				m.obj.setCursorPos(colpos+25,linepos)
				m.obj.write(string.rep(" ", 25)) -- clear the line
				m.obj.setCursorPos(colpos+25,linepos)
				m.obj.write("[" .. t.value.amount .. "]")

				linepos = linepos + 2
				--print(linepos .. " " .. y .. " tids " .. tids)
				if( linepos > y-4 ) then
					linepos = 2
					colpos = 40
				end
				-- if ( linepos >= (maxrows-6) ) then
					-- -- if( colpos + 60 >= x ) then
						-- -- -- do nothing. We don't have screen space
					-- -- --	bhasnext = true -- let the end routine know we have a next button
						-- -- --print("has next!")
						-- -- break
					-- -- end
					-- --print("next column" .. x .. " " .. colpos )
					-- linepos = 2
					-- colpos = 40
					-- print(colpos)
				-- end
				tids = tids + 1
				--print( id .. " " .. dbCount )
				if ( id < dbCount-1 ) then
					bhasnext = true
					else
					bhasnext = false
				end
		end

		id = id + 1

	end
	if( pageid ~= 1 ) then
		m.obj.setCursorPos(2+2, y-1)
		newhit = {} -- our new hit test obj
		topLeft = {}
		bottomRight = {}
		topLeft.x = 2+2
		topLeft.y = y-1
		bottomRight.x = x + #"Back"
		bottomRight.y = y
		newhit.topLeft = topLeft
		newhit.bottomRight = bottomRight
		newhit.func = printItemPageEx
		newhit.funcargs = {}
		newhit.funcargs.db = db
		newhit.funcargs.pageid = pageid - 1
		newhit.funcargs.m = m
		--newhit.funcargs = args
		--newhit.funcargs.pageoverride = pageid+1
		table.insert(hitgrid, newhit)
		m.obj.write("Back")
	end
	if( bhasnext ) then
		--local nextpagestr = "Next Page"
		m.obj.setCursorPos(x- (#"Next Page"+4) , y-1)
		newhit = {} -- our new hit test obj
		topLeft = {}
		bottomRight = {}
		topLeft.x = x- (#"Next Page"+4)
		topLeft.y = y-1
		bottomRight.x = x + #"Next Page"
		bottomRight.y = y
		newhit.topLeft = topLeft
		newhit.bottomRight = bottomRight
		newhit.func = printItemPageEx
		newhit.funcargs = {}
		newhit.funcargs.db = db
		newhit.funcargs.pageid = pageid + 1
		newhit.funcargs.m = m
		--newhit.funcargs = args
		--newhit.funcargs.pageoverride = pageid+1
		table.insert(hitgrid, newhit)
		m.obj.write("Next Page")
	end
	-- print menu selector
	local midpointx = x / 2
	--local midpointy = y / 2
	local strl = #"[Clusters]"
	strl = ((x - (strl))/2)
	local colpos = strl
	local linepos = y
	m.obj.setCursorPos(colpos,linepos)
	newhit = {} -- our new hit test obj
	topLeft = {}
	bottomRight = {}
	topLeft.x = colpos
	topLeft.y = y-1
	bottomRight.x = colpos + #"[Clusters]"
	bottomRight.y = y
	newhit.topLeft = topLeft
	newhit.bottomRight = bottomRight
	newhit.func = printClustersScreenEx
	newhit.funcargs = {}
	newhit.funcargs.clusterdb = storageClusters
	newhit.funcargs.db = db
	newhit.funcargs.pageid = 1
	newhit.funcargs.m = m
	--newhit.funcargs = args
	--newhit.funcargs.pageoverride = pageid+1
	table.insert(hitgrid, newhit)
	m.obj.write("[Clusters]")
	
	m.hitgrid = hitgrid
	return m
	--image = paintutils.loadImage("bar")
	--paintutils.drawImage(image, 3, 5)

end
printClustersScreenEx = function(args)
	args.m.obj.clear()
	--print("Printing clusters page " ..  args.pageid)
	printClustersScreen(args.clusterdb, args.pageid, args.m)
end
printClustersScreen = function(clusterdb, pageid, m)
	--m.clear()
	if( clusterdb == nil ) then	
		clusterdb = {}
	end
	m.obj.setCursorBlink(false)
	m.pageName = "printClustersScreen"
	m.obj.setTextScale(1) --Sets size
	m.pageid = pageid
	
	local hitgrid = {} -- our hit grid for the printed page
	
	local colpos = 3 -- start positions for the page
	local linepos = 2
	--
	local x, y = m.obj.getSize()
	
	local dbCount = 0;

	for key, value in pairs (clusterdb) do
		--value.name = queryItemName(tonumber(value.uuid))
		dbCount = dbCount + 1
	end
	local ndatabase = SortFunc(clusterdb)
	
	table.sort(ndatabase, function(x,y) return x.value.computerLabel < y.value.computerLabel end)

	local maxcols = 1 -- math.floor(x / 30)
	
	
	local maxrows = (y-4) / 2
	local maxitemsdisplayed = math.floor(maxcols * maxrows)
	local startid = maxitemsdisplayed * (pageid-1)--(pageid-1)  cnt;
	--print(startid)
	local id = 0
	local tids = 0
	local bhasnext = false
	--print( "MAX X = " .. x .. " MAX Y = " .. y .. " MAXITEMS = " .. maxitemsdisplayed .. " startid= " .. startid)
	for _,t in ipairs(ndatabase) do 
		--	print( "id " .. id .. " start id " .. startid .. " tids " .. tids .. " max items " .. maxitemsdisplayed )
			if (id >= startid and tids < maxitemsdisplayed ) then
				
				local newhit = {} -- our new hit test obj
				-- we're going to take the top left and bottom right
				local topLeft = {}
				local bottomRight = {}
				
				topLeft.x = colpos
				topLeft.y = linepos
				
				bottomRight.x = colpos + 50
				bottomRight.y = linepos
				
				newhit.topLeft = topLeft
				newhit.bottomRight = bottomRight
				newhit.func = clusterSelectedScreen
				-- args.mon is the current monitor
				-- args.uuid is the UID of the crap we're expecting
				-- args.name is the name of the UUID for human readability
				-- args.cancel is the function to which we default cancel to
				-- args.amount is how much we got
				-- args.count is how much they want, zero for default
				local args = {}
				args.mon = m
				args.computerID = t.value.computerID
				args.computerLabel = t.value.computerLabel
				args.cancel = clusterSelectedScreen
				local cancelargs = {}
				cancelargs.db = database
				cancelargs.clusterdb = clusterdb
				cancelargs.pageid = pageid
				cancelargs.m = m
				args.cancelargs = cancelargs
				--args.amount = t.value.amount
				--args.count = 0
				newhit.funcargs = args
				
				table.insert(hitgrid, newhit)
				
				m.obj.setCursorPos(colpos,linepos)
				m.obj.write(string.rep(" ",25)) -- clear the line
				m.obj.setCursorPos(colpos,linepos)
				m.obj.write(t.value.computerLabel)-- .. "\t" .. " Count = " .. t.value.amount );
				m.obj.setCursorPos(colpos+25,linepos)
				m.obj.write(string.rep(" ", 25)) -- clear the line
				m.obj.setCursorPos(colpos+25,linepos)
				if( t.value.online == true ) then
					m.obj.setBackgroundColour(colours.green)
					m.obj.write("[Online]")
					m.obj.setBackgroundColour(colours.black)
					else
					m.obj.setBackgroundColour(colours.red)
					m.obj.write("[Offline]")
					m.obj.setBackgroundColour(colours.black)
				end
				
				

				linepos = linepos + 2
				--print(linepos .. " " .. y .. " tids " .. tids)
				if( linepos > y-4 ) then
					linepos = 2
					colpos = 40
				end
				-- if ( linepos >= (maxrows-6) ) then
					-- -- if( colpos + 60 >= x ) then
						-- -- -- do nothing. We don't have screen space
					-- -- --	bhasnext = true -- let the end routine know we have a next button
						-- -- --print("has next!")
						-- -- break
					-- -- end
					-- --print("next column" .. x .. " " .. colpos )
					-- linepos = 2
					-- colpos = 40
					-- print(colpos)
				-- end
				tids = tids + 1
				--print( id .. " " .. dbCount )
				if ( id < dbCount-1 ) then
					bhasnext = true
					else
					bhasnext = false
				end
		end

		id = id + 1

	end
	if( pageid ~= 1 ) then
		m.obj.setCursorPos(2+2, y-1)
		newhit = {} -- our new hit test obj
		topLeft = {}
		bottomRight = {}
		topLeft.x = 2+2
		topLeft.y = y-1
		bottomRight.x = x + #"Back"
		bottomRight.y = y
		newhit.topLeft = topLeft
		newhit.bottomRight = bottomRight
		newhit.func = printClustersScreenEx
		newhit.funcargs = {}
		newhit.funcargs.db = database
		newhit.funcargs.clusterdb = clusterdb
		newhit.funcargs.pageid = pageid - 1
		newhit.funcargs.m = m
		--newhit.funcargs = args
		--newhit.funcargs.pageoverride = pageid+1
		table.insert(hitgrid, newhit)
		m.obj.write("Back")
	end
	if( bhasnext ) then
		--local nextpagestr = "Next Page"
		m.obj.setCursorPos(x- (#"Next Page"+4) , y-1)
		newhit = {} -- our new hit test obj
		topLeft = {}
		bottomRight = {}
		topLeft.x = x- (#"Next Page"+4)
		topLeft.y = y-1
		bottomRight.x = x + #"Next Page"
		bottomRight.y = y
		newhit.topLeft = topLeft
		newhit.bottomRight = bottomRight
		newhit.func = printClustersScreenEx
		newhit.funcargs = {}
		newhit.funcargs.db = database
		newhit.funcargs.clusterdb = db
		newhit.funcargs.pageid = pageid + 1
		newhit.funcargs.m = m
		--newhit.funcargs = args
		--newhit.funcargs.pageoverride = pageid+1
		table.insert(hitgrid, newhit)
		m.obj.write("Next Page")
	end
	-- print menu selector
	local midpointx = x / 2
	--local midpointy = y / 2
	local strl = #"[Resources]"
	strl = ((x - (strl))/2)
	local colpos = strl
	local linepos = y
	m.obj.setCursorPos(colpos,linepos)
	newhit = {} -- our new hit test obj
	topLeft = {}
	bottomRight = {}
	topLeft.x = colpos
	topLeft.y = y-1
	bottomRight.x = colpos + #"[Resources]"
	bottomRight.y = y
	newhit.topLeft = topLeft
	newhit.bottomRight = bottomRight
	newhit.func = printItemPageEx
	newhit.funcargs = {}
	newhit.funcargs.db = database
	newhit.funcargs.clusterdb = clusterdb
	newhit.funcargs.pageid = 1
	newhit.funcargs.m = m
	--newhit.funcargs = args
	--newhit.funcargs.pageoverride = pageid+1
	table.insert(hitgrid, newhit)
	m.obj.write("[Resources]")
	m.hitgrid = hitgrid
	return m
	--image = paintutils.loadImage("bar")
	--paintutils.drawImage(image, 3, 5)

end

function hitTest(mons, side, X, Y)
	for i, mon in ipairs(mons) do
		if( mon.side == side ) then
			for i, ht in ipairs(mon.hitgrid) do
				if( Y >= (ht.topLeft.y-1) and Y <= (ht.bottomRight.y+1) and X >= ht.topLeft.x and X <= ht.bottomRight.x) then
					ht.func(ht.funcargs)
				end
			end
		end
	end
end

function updateMonitors(monin)
	local monitors = locateScreens()
	--print( "Found " .. lenTable(monitors) .. " monitors.")
	if( monin == nil or lenTable(monin) == 0) then 
		monin = {} 
	end
	local nextind = 0
	for i, mon in ipairs(monitors) do
		local found = false
		for x, monx in ipairs(monin) do
			if ( monx.side == mon.side ) then
				found = true
				-- update size params
				monx.height = mon.height
				monx.width = mon.width
				if ( monx.obj == nil ) then
					print("Monitor was missing from " .. monx.side .. " but has been restored.")
					monx.obj = mon.obj
				end
			end
		end
		if ( found == false ) then
			mon.obj.clear()
			table.insert(monin, nextind, mon)
			print("Found a new monitor, side = " .. mon.side )
		end

		nextind = nextind + 1
	end
	-- check for removals
	for x, monx in ipairs(monin) do
		if ( not peripheral.isPresent(monx.side) or peripheral.getType(monx.side) ~= "monitor" ) then
			--print("Monitor was located on " .. monx.side .. " but now is gone.")
			monx.obj = nil
		end
	end
	return monin
end

doTicker = function()
	local x = os.clock()
	lastSorterResponse = os.clock()
	local bfirststart = true
	while (true) do
		if (os.clock() - x) > 5 then
			local file = 'idlookup'
			local status, err = pcall(loadLookups, file)
			x = os.clock()
		end
		curmons = updateMonitors(curmons)
		if( bfirststart == true ) then
			--print("First start is true")
			for i, mon in ipairs(curmons) do
				if( mon.obj ~= nil ) then
					
					printToCenterScreen(mon.obj, "WEEBLER STORAGE", 1)
					sleep(1.5)
					printToCenterScreen(mon.obj, "Starting up. Please wait..", 1)
					--sleep(10)
					--print(mon.side .. " has " .. lenTable(mon.hitgrid) .. " items" )
				end
			end
			bfirststart = false
		end
		if ( os.clock() - lastSorterResponse > 30 ) then
			for i, mon in ipairs(curmons) do
				if( mon.obj ~= nil ) then
					--if( mon.pageid == nil ) then mon.pageid = 1 end
					mon = printDisconnectedPage(mon)
					mon.pageid = nil
					mon.pageName = nil
					sleep(1)
					--print(mon.side .. " has " .. lenTable(mon.hitgrid) .. " items" )
				end
			end
			else
			for i, mon in ipairs(curmons) do
				if( mon.obj ~= nil and (mon.pageName == nil or mon.pageName == "printItemPage") ) then
					if( mon.pageid == nil ) then 
						mon.pageid = 1 
						mon.obj.clear()
					end
					mon = printItemPage(database, mon.pageid, mon)
					--print(mon.side .. " has " .. lenTable(mon.hitgrid) .. " items" )
				end
				if( mon.obj ~= nil and (mon.pageName == nil or mon.pageName == "printClustersScreen") ) then
					if( mon.pageid ~= nil ) then 
						--mon.pageid = 1 
						--mon.obj.clear()
						mon = printClustersScreen(storageClusters, mon.pageid, mon)
					end
					
					--print(mon.side .. " has " .. lenTable(mon.hitgrid) .. " items" )
				end
			end
		end
		
		--local checkm = locateScreens()


		sleep(1)
	end
end


main = function()
 	local x = os.clock()
	while (true) do
		id, message  = rednet.receive(1)
		if id ~= nill and id ~= os.getComputerID() then
			--print("Received a message..." .. id)
			--print(message)
			--local b, c
			local b, t, c, to = validateWeeblerMsg(message)
			if  (b == true ) then
				--if( c == "getResponse" ) then print("Received a valid message, processing command: " .. message ) end
				processCmd(t, c, id, to)
				
			end
		end
	end
	--print(string.format("elapsed time: %.2f\n", os.clock() - x))
end
function2 = function()
	rednet.broadcast(makemsg(os.getComputerID(), 0, "query", ""))
end

sendLoop = function()
	while (true) do
		local msg = makemsg( os.getComputerID(), 0, "queryStorage", "" )
		
		--print( msg )
		rednet.broadcast(msg)
		msg = makemsg( os.getComputerID(), 0, "queryClusterList", "" )
		rednet.broadcast(msg)
		sleep(10)
	end
end

function key1(x1, x2, y1, y2)
event, side, X, Y = os.pullEventRaw()
  if event == "monitor_touch" then
	
	--print("X = " .. X .. ", Y = " .. Y .. ", side = " .. side )
	hitTest(curmons, side, X, Y)
  else

  end
end

touchLoop = function()
	while true do
	  key1(2, 6, 1, 3)
	end
end

local modemInit = initModem()
if( modemInit ~= true ) then return end
if ( os.getComputerLabel() == nil or os.getComputerLabel == "" ) then
	os.setComputerLabel(tostring(os.getComputerID()))
end
parallel.waitForAll (main, sendLoop, doTicker, touchLoop)
